#include <stdlib.h>
#include <assert.h>
#include <time.h>

#include "heading.h"
#include "huffman.h"
#include "../../priority_queue.h"

void init_huffman_heading(HuffmanHeading* heading) {
    heading->ignoreBits = 0;
    heading->signature = SIG_HUFFMAN;
    heading->treeShapeSize = 0;
    heading->treeLeavesSize = 0;
    heading->treeShape = makelist();
    heading->treeLeaves = makelist();
}

/**
 * Takes filename, finds weight of each symbol in this file
 * Result: an array of size 256, where index of each element
 * represents a single unique byte; the value of each element
 * is weight (0 - file doesn't contain this byte)
 */
static void find_bytes_weight(FILE* fileIn, long* weights) {
    while (true) {
        int bytesRead = fread(buffer, sizeof(uint8_t), BLOCK_SIZE, fileIn);
        if (bytesRead <= 0) {
            break;
        }
        /* Determine unique bytes in current block */
        for (size_t i = 0; i < bytesRead; i++) {
            size_t index = buffer[i] & 0xff; /* Cast byte to unsigned integer */
            weights[index]++;
        }
    }
}

int weights_comparator(const void *item_1, const void *item_2)
{
    HuffmanTreeNode *node_1, *node_2;

    node_1 = (HuffmanTreeNode*) item_1;
    node_2 = (HuffmanTreeNode*) item_2;

    if(node_1->weight < node_2->weight) {
        return SMALLER;
    } else if(node_1->weight == node_2->weight) {
        return EQUAL;
    } else {
        return GREATER;
    }
}

HuffmanTreeNode* build_huffman_tree(FILE* fileIn) {
    long weights[UINT8_COUNT] = {0};
    find_bytes_weight(fileIn, weights);

#ifdef DEBUG
    printf("Generated bytes weights:\n");
    for (size_t i = 0; i < UINT8_COUNT; i++) {
        if (i != 0 && i % 16 == 0) {
            printf("\n");
        }
        printf("%ld\t", weights[i]);
    }
    printf("\n\n");
#endif
    priority_queue *forest = create_priority_queue(UINT8_COUNT, &weights_comparator);

    for (size_t i = 0; i < UINT8_COUNT; i++) {
        if (weights[i] == 0) { /* Current byte has zero weight */
            continue;
        }
        /* Creating initial set of nodes */
        HuffmanTreeNode* node = malloc(sizeof(HuffmanTreeNode));
        node->weight = weights[i];
        node->uniqueByte = i;
        node->hasValue = true;
        node->right = NULL;
        node->left = NULL;

        priority_queue_insert(forest, node);
    }
    while (priority_queue_size(forest) != 1) {
        HuffmanTreeNode* left = priority_queue_poll(forest);
        HuffmanTreeNode* right = priority_queue_poll(forest);

        assert(right != NULL);
        assert(left != NULL);

        HuffmanTreeNode* newNode = malloc(sizeof(HuffmanTreeNode));
        newNode->weight = left->weight + right->weight;
        newNode->hasValue = false;
        newNode->left = left;
        newNode->right = right;
        priority_queue_insert(forest, newNode);
    }
    HuffmanTreeNode* root = priority_queue_poll(forest);
#ifdef DEBUG
        printf("Root tree node: weight %ld + %ld = %ld\n\n", root->left->weight,
                                            root->right->weight, root->weight);
#endif
    return root;
}

void free_huffman_tree(HuffmanTreeNode* tree) {
    if (!tree) {
        return;
    }
    if (!tree->left && !tree->right) { /* Tree leaf */
        free(tree);
        return;
    }
    /* Otherwise, it's a parent node */
    free_huffman_tree(tree->left);
    free_huffman_tree(tree->right);
}